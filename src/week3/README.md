1. Пакет sort:
   Условие: В классе DuckSortTestDrive нужно отсортировать уточек по весу (см. TODO)
   Решение: TODO нужно заменить на Arrays.sort(ducks);
            Класс Duck должен implements Comparable
            В классе Duck нужно реализовать метод compareTo (сравниваем уточек по полю weight)

2. Пакет barista:
   Условие:Добавить в реализацию абстракцию, которая поможет убрать дублирование кода.
   Логику приготовления напитка нужно абстрагировать, изменить классы Coffee и Tea после абстракции.
   Решение:
        1. Необходимо создать абстрактный класс CaffeineBeverage
        2. В классе будут реализованы методы:
              prepareRecipe(). Здесь можно подчеркнуть, что метод final. Т.е. последовательность приготовления напитка нельзя переопределить
              boilWater()
              pourInCup()
        3. В классе будут абстрактные методы:
              brew()
              addCondiments()
              Так как эти методы у классов Tea и Coffee были реализованы по-разному
        4. В классах Tea и Coffee добавляем наследование от CaffeineBeverage
        5. В классах Tea и Coffee переопределяем методы  brew() и addCondiments()

3. Пакет testequals:
   Условие:Класс Point описывает точку в двухмерном пространстве
           Класс ColorPoint описывает цветную точку в двухмерном пространстве
           Есть ли нарушения в общих соглашениях для метода equals при сравнении этих двух классов?
           Как исправить?
   Решение:
           1. Можно попытаться ColorPoint.equals игнорировать цвет при выполнении смешанных сравнений.
              Сейчас мы имеем нарушение симметричности, исправим его, но получим нарушение транзитивности:
                public boolean equals(Object o) {
                      if (!(o instanceof Point)) return false;
                      //Если o - обычный point, выполним сравнение без цвета
                      if (!(o instanceof ColorPoint)) return o.equals(this);

                      ColorPoint cp = (ColorPoint) o;
                      return super.equals(o) && cp.color.equals(color);
                  }
              Пример:
              ColorPoint p1 = new ColorPoint(1, 2, Color.RED);
              Point p2 = new Point(1, 2);
              ColorPoint p3 = new ColorPoint(1, 2, Color.BLUE);
              В этом случае выражение p1.equals(p2) и p2.equals(p3) возвращают значения true, а p1.equals(p3)
              возвращает значение false.
              Прямое нарушение транзитивности!
           2. Можно сделать так:
              Делать проверку класса, а не наследника класса.
           3. Можно воспользоваться принципом "Предпочитайте композицию наследованию". См. класс ColorPointComposition.
              Данный класс не наследуется от Point, а хранит ссылки на Color и Point в реквизитах.